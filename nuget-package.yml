# Notes
# - Secret variables do not work for pull request builds, if we want to deploy from such builds, we need some other way to handle Git and Nuget personal access tokens

parameters:
  buildConfiguration: "Release"
  runInheritDoc: true
  runTests: true
  runCodeCoverage: true
  codecovKey: "$(codecovKey)"
  changelogPath: "CHANGELOG.md"
  versionHeaderPattern: '^##[ \t]*\[(\d+\.\d+\.\d+[0-9A-Za-z-.]*)\]'
  # TODO allow for multiple endpoints
  nugetRestoreEndpoint: "https://www.nuget.org/api/v2/package"
  nugetRestorePat: "$(nugetRestorePat)"
  nugetPushEndpoint: "https://www.nuget.org/api/v2/package"
  nugetPushPat: "$(nugetPushPat)"
  nugetDistUrl: "https://dist.nuget.org/win-x86-commandline/v4.7.1/nuget.exe"
  githubPat: "$(githubPat)"

jobs:
# Build
- job: "Build"
  pool:
    vmImage: "vs2017-win2016"
  steps:
  - powershell: |
      function Render-Body { $input | foreach{@{value=$_}} | Format-Table -Property @{Expression={" "}},value -HideTableHeader -wrap}

      # Place cache in working directory so that it is uploaded to pipeline artifacts
      $env:NUGET_PACKAGES=$env:SYSTEM_DEFAULTWORKINGDIRECTORY + "/packages"

      if($env:NUGET_RESTORE_ENDPOINT){
        "Nuget restore endpoint specified...`n"

        "Installing Nuget:`n"
        Invoke-WebRequest $env:NUGET_DIST_URL -outfile nuget.exe | Render-Body
        "    Nuget v4.7.1 installed.`n"

        "Generating empty NuGet.Config:`n"
        [IO.File]::WriteAllLines($env:SYSTEM_DEFAULTWORKINGDIRECTORY + "/NuGet.Config", '<?xml version="1.0" encoding="utf-8"?><configuration><packageSources><clear /></packageSources></configuration>')
        "    Empty NuGet.Config generated.`n"

        $sourceName = 'nugetRestoreEndpoint'
        if($env:NUGET_RESTORE_PAT){
          "Adding source with API key:"          
          .\nuget.exe sources add -Name $sourceName -Source $env:NUGET_RESTORE_ENDPOINT -Username 'placeholder' -Password $env:NUGET_RESTORE_PAT -configfile '.\Nuget.Config' -StorePasswordInClearText | Render-Body
        }
        else {
          "Adding source:"
          .\nuget.exe sources add -Name $sourceName -Source $env:NUGET_RESTORE_ENDPOINT -configfile '.\Nuget.Config' | Render-Body
        }
      }

      "Restoring packages:"
      dotnet restore | Render-Body

      "Building solution:"
      dotnet build --no-restore --configuration Release -p:CopyLocalLockFileAssemblies=true | Render-Body

      if($env:RUN_INHERIT_DOC -eq 'true'){
        "Installing InheritDoc:"
        dotnet tool install InheritDocTool --tool-path . | Render-Body # Install to current dir https://github.com/dotnet/cli/issues/8368

        "Running InheritDoc:"
        .\InheritDoc.exe -b src -o | Render-Body

        # We won't be needing InheritDoc again in the pipeline
        remove-item .\InheritDoc.exe
        remove-item .\.store -recurse
      }

      # Unhide .git folder and rename it so that PublishPipelineArtifact picks it up
      attrib -h .git
      rename-item .git git
    displayName: "Build"
    env:
      NUGET_DIST_URL: ${{parameters.nugetDistUrl}}
      NUGET_RESTORE_ENDPOINT: ${{parameters.nugetRestoreEndpoint}}
      NUGET_RESTORE_PAT: ${{parameters.nugetRestorePat}}
      RUN_INHERIT_DOC: ${{parameters.runInheritDoc}}
  # Publish entire working directory to artifacts - https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases?view=vsts&tabs=yaml#artifact-download
  - task: "PublishPipelineArtifact@0"
    displayName: "Publish Working Directory"
    inputs:
      artifactName: "builtSolution"
      targetPath: "$(System.DefaultWorkingDirectory)"
# Test
- ${{if eq(parameters.runTests, 'true')}}:
  - job: "WindowsTests"
    dependsOn: "Build"
    pool:
      vmImage: "vs2017-win2016"
    steps:
    # Skip checking out the default repository resource
    - checkout: "none"
    # Download entire working directory from pipeline artifacts
    - task: "DownloadPipelineArtifact@0"
      displayName: "Download Working Directory"
      inputs:
        artifactName: "builtSolution"
        targetPath: "$(System.DefaultWorkingDirectory)"
    # Test and handle code coverage report
    - powershell: |
        function Render-Body { $input | foreach{@{value=$_}} | Format-Table -Property @{Expression={" "}},value -HideTableHeader -wrap}

        # Make sure dotnet knows to look for packages in ./packages
        $env:NUGET_PACKAGES=$env:SYSTEM_DEFAULTWORKINGDIRECTORY + "/packages"

        "Running tests:"
        dotnet test --no-build --no-restore --configuration Release --logger trx --results-directory $(Agent.TempDirectory) -p:CollectCoverage=$env:RUN_CODE_COVERAGE -p:CoverletOutputFormat=cobertura | Render-Body

        $reports = get-childitem coverage.cobertura.xml -Recurse | foreach{$_.fullname}
        # No reports
        if($reports.length -eq 0){
          "No code coverage reports generated..."
          exit
        }

        # .git folder was named git so that PublishPipelineArtifact picked it up, codecov must be run from the root of a repository
        rename-item git .git

        # Publish report to codecov
        "Publishing code coverage report(s)...`n"

        "Installing Codecov:"      
        choco install codecov --yes --no-progress --cache-location=. | Render-Body 

        "Publishing to Codecov:"
        codecov -f $reports -t "$env:CODECOV_KEY" --required | Render-Body # Exit code 1 if uploading of report fails, otherwise it may fail silently
      displayName: "Test"
      #TODO remove once parameters can be used directly in scripts
      env:
        CODECOV_KEY: ${{parameters.codecovKey}}
        RUN_CODE_COVERAGE: ${{parameters.runCodeCoverage}}
    - task: "PublishTestResults@2"
      inputs:
        testResultsFormat: "VSTest"
        testResultsFiles: "**/*.trx"
        searchFolder: "$(Agent.TempDirectory)"
        testRunTitle: "WindowsTests"
  - template: "nuget-package-test.yml"
    parameters:
      name: "LinuxTests"
      vmImage: "ubuntu-16.04"
      buildConfiguration: ${{ parameters.buildConfiguration }}
  - template: "nuget-package-test.yml"
    parameters:
      name: "macOSTests"
      vmImage: "macOS-10.13"
      buildConfiguration: ${{ parameters.buildConfiguration }}
# Deploy
- job: "Deploy"
  dependsOn:
  - ${{if eq(parameters.runTests, 'true')}}:
    - "WindowsTests"
    - "LinuxTests"
    - "macOSTests"
  - ${{if ne(parameters.runTests, 'true')}}:
    - "Build"
  steps:
  - checkout: "none"
  # Download entire working directory from artifacts
  - task: "DownloadPipelineArtifact@0"
    displayName: "Download Working Directory"
    inputs:
      artifactName: "builtSolution"
      targetPath: "$(System.DefaultWorkingDirectory)"
  - powershell: |
      function Render-Body { $input | foreach{@{value=$_}} | Format-Table -Property @{Expression={" "}},value -HideTableHeader -wrap}

      # We've set triggers to commits to master and commits to branches with open pull requests 
      # to master. Only commits to master might have stuff to deploy.
      # TODO If we use $env:BUILD_REASON -eq 'PullRequest', do manual rebuilds cause deploys?
      if($env:BUILD_SOURCEBRANCHNAME -ne 'master'){
        "Pull request build, nothing to deploy"
        exit
      }
      "`nCommit is a merge commit into master...`n"

      # .git folder was named git so that PublishPipelineArtifact picked it up
      rename-item git .git
      
      # Initialize convenience variables
      $commit = $env:BUILD_SOURCEVERSION

      # Check whether changelog has changed
      # Note: -m displays a diff of the parents of a merge commit
      $changedFiles = git show -m --pretty="" --name-only $commit
      "Changed files:"
      $changedFiles | Render-Body 
      if(-not($changedFiles -contains $env:CHANGELOG_PATH)) {
        "Changelog unchanged, nothing to deploy."
        exit
      }
      "Changelog has changed...`n"

      # Check whether changelog has a new version
      $addedLines = git diff --unified=0 $commit^ $commit -- $env:CHANGELOG_PATH | foreach{if($_[0] -eq '+'){$_.Substring(1)}}
      "Added Lines:"
      $addedLines | Render-Body

      foreach($addedLine in $addedLines) {
        if($addedLine -match $env:VERSION_HEADER_PATTERN){
          $newVersion = $matches[1]
          break
        }
      }
      if(-not($newVersion)) {
        "No new version, nothing to deploy."
        exit
      }
      "New version `"$newVersion`" found...`n"
    
      # Make sure dotnet knows to look for packages in ./packages
      $env:NUGET_PACKAGES=$env:SYSTEM_DEFAULTWORKINGDIRECTORY + "/packages"

      "Packing Nuget package(s):"
      dotnet pack --no-restore --no-build --configuration $env:BUILD_CONFIGURATION -p:PackageVersion=$newVersion | Render-Body

      # Push using endpoint and api key
      "Pushing packages:"
      $packages = get-childitem src *.nupkg -Recurse
      foreach($package in $packages) {
        dotnet nuget push $package.fullname --source $env:NUGET_ENDPOINT --api-key $env:NUGET_PUSH_PAT | Render-Body
      }

      # Create new tag
      "Tagging commit:"      
      $commitAuthorName = git show --pretty="%an" --quiet
      "    Commit author name: " + $commitAuthorName
      git config user.name $commitAuthorName
      
      $commitAuthorEmail = git show --pretty="%ae" --quiet
      "    Commit author email: " + $commitAuthorEmail
      git config user.email $commitAuthorEmail

      git tag -a $newVersion -m "Azure build ID: $env:BUILDID"

      $uri = $env:BUILD_REPOSITORY_URI -replace "github.com", "$env:GITHUB_PAT@github.com"
      "`nPushing tag to Github:"
      git push -u $uri $newVersion -q | Render-Body
      "    Tag $newVersion pushed to Github."
    displayName: "Deploy"
    # TODO When template parameters can be used in scripts, remove this - https://github.com/Microsoft/azure-pipelines-agent/issues/1772
    env:
      CHANGELOG_PATH: ${{parameters.changelogPath}}
      VERSION_HEADER_PATTERN: ${{parameters.versionHeaderPattern}}
      BUILD_CONFIGURATION: ${{parameters.buildConfiguration}}
      NUGET_ENDPOINT: ${{parameters.nugetPushEndpoint}}
      NUGET_PUSH_PAT: ${{parameters.nugetPushPat}}
      GITHUB_PAT: ${{parameters.githubPat}}