# Notes
# - Secret variables do not work for pull request builds, if we want to deploy from such builds, we need some other way to handle Git and Nuget personal access tokens
# - what is https://docs.microsoft.com/en-us/azure/devops/pipelines/build/ci-public?view=vsts&tabs=github? can it be used instead of PAT?

# TODO output formatting, docs
# foreach{@{value=$_}}| Format-Table -Property @{Expression={" "}},value -HideTableHeader -wrap

parameters:
  changelogPath: "CHANGELOG.md"
  versionHeaderPattern: '^\+##[ \t]*\[(\d+\.\d+\.\d+[0-9A-Za-z-.]*)\]'
  nugetEndpoint: "https://staging.nuget.org/api/v2/package"
  nugetApiKey: "$(nugetApiKey)"
  codecovKey: "$(codecovKey)"
  buildConfiguration: "Release"
  vstsFeedName: "NugetFeed"

jobs:
# Build
- job: "Build"
  pool:
    vmImage: "vs2017-win2016"
  steps:
  - task: "DotNetCoreCLI@2"
    displayName: "Restore"
    inputs: 
      command: "restore"
      includeNuGetOrg: false
      vstsFeed: ${{parameters.vstsFeedName}}
  - task: "DotNetCoreCLI@2"
    displayName: "Build"
    inputs: 
      command: "build"
      # TODO not sure why this doesn't work, possible - https://github.com/Microsoft/azure-pipelines-agent/issues/1772
      # arguments: --no-restore --configuration ${{parameters.buildConfiguration}} -p:CopyLocalLockFileAssemblies=true
      arguments: "--no-restore --configuration Release -p:CopyLocalLockFileAssemblies=true"
  - powershell: |
      dotnet tool install InheritDocTool --tool-path . # Install to current dir https://github.com/dotnet/cli/issues/8368
      .\InheritDoc.exe -b src -o
      # We won't be needing InheritDoc again in the pipeline
      remove-item .\InheritDoc.exe
      remove-item .\.store -recurse
    displayName: "Handle <inheritdoc /> in XML Comments"
  - powershell: |
      # Unhide .git folder and rename it so that PublishPipelineArtifact picks it up
      attrib -h .git
      rename-item .git git
    displayName: "Prepare Intermediate Artifacts"
    env:
      BUILD_CONFIGURATION: ${{ parameters.buildConfiguration }} # TODO When template parameters can be used in scripts, remove this - https://github.com/Microsoft/azure-pipelines-agent/issues/1772
  # Publish entire working directory to artifacts - https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases?view=vsts&tabs=yaml#artifact-download
  - task: "PublishPipelineArtifact@0"
    displayName: "Publish Working Directory"
    inputs:
      artifactName: "builtSolution"
      targetPath: "$(System.DefaultWorkingDirectory)"
# Test
- job: "WindowsTests"
  pool:
    vmImage: "vs2017-win2016"
  dependsOn: "Build"
  steps:
  # Skip checking out the default repository resource
  - checkout: "none"
  # Download entire working directory from pipeline artifacts
  - task: "DownloadPipelineArtifact@0"
    displayName: "Download Working Directory"
    inputs:
      artifactName: "builtSolution"
      targetPath: "$(System.DefaultWorkingDirectory)"
  # Test and handle code coverage report
  - powershell: |
      # Test
      dotnet restore # TODO cache packages separately from working dir and download before these tests?
      dotnet test --no-build --configuration Release --logger trx --results-directory $(Agent.TempDirectory) -p:CollectCoverage=true -p:CoverletOutputFormat=cobertura

      # No reports
      $reports = get-childitem coverage.cobertura.xml -Recurse
      if($reports.length -eq 0){
        "No code coverage reports generated..."
        exit
      }

      "Reports:"
      $reports
      $finalReportPath = ''
      # Multiple reports
      if($reports.length -gt 1){
        # Merge  reports
        "`nMultiple reports found, merging reports..."
        $reportPaths = ''
        foreach($report in $reports) {
          $reportPaths = $reportPaths + $report.fullname + ';'
        }
        dotnet tool install dotnet-reportgenerator-globaltool --tool-path . # Install to current dir https://github.com/dotnet/cli/issues/8368
        .\reportgenerator.exe -reports:$reportPaths -targetdir:. -reporttypes:cobertura
        $finalReportPath = 'Cobertura.xml'
      }else{
        # Single report
        $finalReportPath = $reports[0].fullname
      }

      # .git folder was named git so that PublishPipelineArtifact picked it up, codecov must be run from the root of a repository
      rename-item git .git

      # Publish report to codecov
      "`nPublishing report to codecov..."
      choco install codecov --yes --no-progress --cache-location=.
      codecov -f $finalReportPath -t "$env:CODECOV_KEY" --required # Exit code 1 if uploading of report fails, otherwise it may fail silently
    displayName: "Test and Publish Code Coverage Report"
    env:
      CODECOV_KEY: ${{parameters.codecovKey}} #TODO remove once parameters can be used directly in scripts
  - task: "PublishTestResults@2"
    inputs:
      testResultsFormat: "VSTest"
      testResultsFiles: "**/*.trx"
      searchFolder: "$(Agent.TempDirectory)"
      testRunTitle: "WindowsTests"
- template: "nuget-package-test.yml"
  parameters:
    name: "LinuxTests"
    vmImage: "ubuntu-16.04"
    buildConfiguration: ${{ parameters.buildConfiguration }}
- template: "nuget-package-test.yml"
  parameters:
    name: "macOSTests"
    vmImage: "macOS-10.13"
    buildConfiguration: ${{ parameters.buildConfiguration }}
# Deploy
- job: "Deploy"
  dependsOn:
  - "WindowsTests"
  - "LinuxTests"
  - "macOSTests"
  steps:
  - checkout: "none"
  # Download entire working directory from artifacts
  - task: "DownloadPipelineArtifact@0"
    displayName: "Download Working Directory"
    inputs:
      artifactName: "builtSolution"
      targetPath: "$(System.DefaultWorkingDirectory)"
  - powershell: |
      # We've set triggers to commits to master and commits to branches with open pull requests 
      # to master. Only commits to master might have stuff to deploy.
      # TODO If we use $env:BUILD_REASON -eq 'PullRequest', do manual rebuilds cause deploys?
      "Current commit's branch: " + $env:BUILD_SOURCEBRANCHNAME
      if($env:BUILD_SOURCEBRANCHNAME -ne 'master'){
        "Pull request build, nothing to deploy"
        exit
      }
      "Commit is a merge commit into master...`n"

      # .git folder was named git so that PublishPipelineArtifact picked it up
      rename-item git .git
      
      # Initialize convenience variables
      $commit = $env:BUILD_SOURCEVERSION

      # Check whether changelog has changed
      # Note: -m displays a diff of the parents of a merge commit
      $changedFiles = git show -m --pretty="" --name-only $commit
      "Changed files:"
        $changedFiles
      if(-not($changedFiles -contains $env:CHANGELOG_PATH)) {
        "Changelog unchanged, nothing to deploy."
        exit
      }
      "Changelog has changed...`n"

      # Check whether changelog has a new version
      $diff = git diff --unified=0 $commit^ $commit -- $env:CHANGELOG_PATH
      "Diff:"
      $diff
      $newVersionLines = $diff -match $env:VERSION_HEADER_PATTERN
      if($newVersionLines.Length -gt 1) {
        throw "More than one new versions found, correct changelog or deploy releases manually."
      }
      if($newVersionLines.length -eq 0) {
        "No new versions, nothing to deploy."
        exit
      }
      $newVersionLines[0] -match $env:VERSION_HEADER_PATTERN
      $newVersion = $matches[1]
      "New version `"$newVersion`" found..."

      # Check whether tag exists for version
      # TODO remove this? just always run so that if in a previous build tagging succeeded but publishing of nuget package failed, it can be 
      # re-done in a manual build.
      $tags = git tag -l
      "Existing tags:"
      $tags
      if($tags -contains $newVersion) {
        "New version already deployed, nothing to deploy."
        exit
      }
      "New version not deployed yet, deploying..."

      # Pack working dir (dont rebuild)
      dotnet pack --no-restore --no-build --configuration $env:BUILD_CONFIGURATION -p:PackageVersion=$newVersion

      # Publish to nuget.org
      $packages = get-childitem src *.nupkg -Recurse
      "Packages:"
      $packages
      foreach($package in $packages) {
        dotnet nuget push $package.fullname --source $env:NUGET_ENDPOINT --api-key $env:NUGET_API_KEY
      }

      # Create new tag
      $commitAuthorName = git show --pretty="%an" --quiet
      "Commit author name: " + $commitAuthorName
      git config user.name $commitAuthorName
      
      $commitAuthorEmail = git show --pretty="%ae" --quiet
      "Commit author email: " + $commitAuthorEmail
      git config user.email $commitAuthorEmail

      git tag -a $newVersion -m "Azure build ID: $env:BUILDID"

      $uri = $env:BUILD_REPOSITORY_URI -replace "github.com", "$(githubPat)@github.com"
      git push -u $uri $newVersion -q
      "Tag $newVersion created and pushed to origin."
    displayName: "Deploy Nuget Package and Tag Commit"
    # TODO When template parameters can be used in scripts, remove this - https://github.com/Microsoft/azure-pipelines-agent/issues/1772
    env:
      CHANGELOG_PATH: ${{parameters.changelogPath}}
      VERSION_HEADER_PATTERN: ${{parameters.versionHeaderPattern}}
      NUGET_ENDPOINT: ${{parameters.nugetEndpoint}}
      NUGET_API_KEY: ${{parameters.nugetApiKey}}
      BUILD_CONFIGURATION: ${{parameters.buildConfiguration}}