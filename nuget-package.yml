# Notes
# - Secret variables do not work for pull request builds, if we want to deploy from such builds, we need some other way to handle Git and Nuget personal access tokens
# - what is https://docs.microsoft.com/en-us/azure/devops/pipelines/build/ci-public?view=vsts&tabs=github? can it be used instead of PAT?

# TODO docs

parameters:
  changelogPath: "CHANGELOG.md"
  versionHeaderPattern: '^\+##[ \t]*\[(\d+\.\d+\.\d+[0-9A-Za-z-.]*)\]'
  nugetEndpoint: "https://www.nuget.org/api/v2/package"
  nugetApiKey: "$(nugetApiKey)"
  codecovKey: "$(codecovKey)"
  buildConfiguration: "Release"
  vstsFeedName: "NugetFeed"

jobs:
# Build
- job: "Build"
  pool:
    vmImage: "vs2017-win2016"
  steps:
  - task: "DotNetCoreCLI@2"
    displayName: "Restore"
    inputs: 
      command: "restore"
      includeNuGetOrg: false
      vstsFeed: ${{parameters.vstsFeedName}}
  - task: "DotNetCoreCLI@2"
    displayName: "Build"
    inputs: 
      command: "build"
      # TODO not sure why this doesn't work, possible - https://github.com/Microsoft/azure-pipelines-agent/issues/1772
      # arguments: --no-restore --configuration ${{parameters.buildConfiguration}} -p:CopyLocalLockFileAssemblies=true
      arguments: "--no-restore --configuration Release -p:CopyLocalLockFileAssemblies=true"
  - powershell: |
      function Render-Body { $input | foreach{@{value=$_}} | Format-Table -Property @{Expression={" "}},value -HideTableHeader -wrap}

      "Installing InheritDoc:"
      dotnet tool install InheritDocTool --tool-path . | Render-Body # Install to current dir https://github.com/dotnet/cli/issues/8368

      "Running InheritDoc:"
      .\InheritDoc.exe -b src -o | Render-Body

      # We won't be needing InheritDoc again in the pipeline
      remove-item .\InheritDoc.exe
      remove-item .\.store -recurse
    displayName: "Handle <inheritdoc /> in XML Comments"
  - powershell: |
      # Unhide .git folder and rename it so that PublishPipelineArtifact picks it up
      attrib -h .git
      rename-item .git git
    displayName: "Prepare Intermediate Artifacts"
    env:
      BUILD_CONFIGURATION: ${{ parameters.buildConfiguration }} # TODO When template parameters can be used in scripts, remove this - https://github.com/Microsoft/azure-pipelines-agent/issues/1772
  # Publish entire working directory to artifacts - https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases?view=vsts&tabs=yaml#artifact-download
  - task: "PublishPipelineArtifact@0"
    displayName: "Publish Working Directory"
    inputs:
      artifactName: "builtSolution"
      targetPath: "$(System.DefaultWorkingDirectory)"
# Test
- job: "WindowsTests"
  pool:
    vmImage: "vs2017-win2016"
  dependsOn: "Build"
  steps:
  # Skip checking out the default repository resource
  - checkout: "none"
  # Download entire working directory from pipeline artifacts
  - task: "DownloadPipelineArtifact@0"
    displayName: "Download Working Directory"
    inputs:
      artifactName: "builtSolution"
      targetPath: "$(System.DefaultWorkingDirectory)"
  # Restore from Azure Artifacts feed for quicker restore (coverlet assemblies are required)
  - task: "DotNetCoreCLI@2"
    displayName: "Restore"
    inputs: 
      command: "restore"
      includeNuGetOrg: false
      vstsFeed: ${{parameters.vstsFeedName}}
  # Test and handle code coverage report
  - powershell: |
      function Render-Body { $input | foreach{@{value=$_}} | Format-Table -Property @{Expression={" "}},value -HideTableHeader -wrap}

      "Running tests:"
      dotnet test --no-build --no-restore --configuration Release --logger trx --results-directory $(Agent.TempDirectory) -p:CollectCoverage=true -p:CoverletOutputFormat=cobertura | Render-Body

      # No reports
      $reports = get-childitem coverage.cobertura.xml -Recurse | foreach{$_.fullname}
      if($reports.length -eq 0){
        "No code coverage reports generated..."
        exit
      }

      # .git folder was named git so that PublishPipelineArtifact picked it up, codecov must be run from the root of a repository
      rename-item git .git

      # Publish report to codecov
      "Publishing code coverage report(s)...`n"

      "Installing Codecov:"      
      choco install codecov --yes --no-progress --cache-location=. | Render-Body 

      "Publishing to Codecov:"
      codecov -f $reports -t "$env:CODECOV_KEY" --required | Render-Body # Exit code 1 if uploading of report fails, otherwise it may fail silently
    displayName: "Test and Publish Code Coverage Report"
    env:
      CODECOV_KEY: ${{parameters.codecovKey}} #TODO remove once parameters can be used directly in scripts
  - task: "PublishTestResults@2"
    inputs:
      testResultsFormat: "VSTest"
      testResultsFiles: "**/*.trx"
      searchFolder: "$(Agent.TempDirectory)"
      testRunTitle: "WindowsTests"
- template: "nuget-package-test.yml"
  parameters:
    name: "LinuxTests"
    vmImage: "ubuntu-16.04"
    buildConfiguration: ${{ parameters.buildConfiguration }}
- template: "nuget-package-test.yml"
  parameters:
    name: "macOSTests"
    vmImage: "macOS-10.13"
    buildConfiguration: ${{ parameters.buildConfiguration }}
# Deploy
- job: "Deploy"
  dependsOn:
  - "WindowsTests"
  - "LinuxTests"
  - "macOSTests"
  steps:
  - checkout: "none"
  # Download entire working directory from artifacts
  - task: "DownloadPipelineArtifact@0"
    displayName: "Download Working Directory"
    inputs:
      artifactName: "builtSolution"
      targetPath: "$(System.DefaultWorkingDirectory)"
  - powershell: |
      function Render-Body { $input | foreach{@{value=$_}} | Format-Table -Property @{Expression={" "}},value -HideTableHeader -wrap}

      # We've set triggers to commits to master and commits to branches with open pull requests 
      # to master. Only commits to master might have stuff to deploy.
      # TODO If we use $env:BUILD_REASON -eq 'PullRequest', do manual rebuilds cause deploys?
      if($env:BUILD_SOURCEBRANCHNAME -ne 'master'){
        "Pull request build, nothing to deploy"
        exit
      }
      "`nCommit is a merge commit into master...`n"

      # .git folder was named git so that PublishPipelineArtifact picked it up
      rename-item git .git
      
      # Initialize convenience variables
      $commit = $env:BUILD_SOURCEVERSION

      # Check whether changelog has changed
      # Note: -m displays a diff of the parents of a merge commit
      $changedFiles = git show -m --pretty="" --name-only $commit
      "Changed files:"
      $changedFiles | Render-Body 
      if(-not($changedFiles -contains $env:CHANGELOG_PATH)) {
        "Changelog unchanged, nothing to deploy."
        exit
      }
      "Changelog has changed...`n"

      # Check whether changelog has a new version
      $diff = git diff --unified=0 $commit^ $commit -- $env:CHANGELOG_PATH
      "Changelog diff:"
      $diff | Render-Body

      $addedLines = $diff -match '^+'
      "Added Lines:"
      $addedLines | Render-Body

      $newVersionLines = $diff -match $env:VERSION_HEADER_PATTERN
      if($newVersionLines.Length -gt 1) {
        throw "More than one new versions found, correct changelog or deploy releases manually."
      }
      if($newVersionLines.length -eq 0) {
        "No new versions, nothing to deploy."
        exit
      }
      $newVersionLines[0] -match $env:VERSION_HEADER_PATTERN
      $newVersion = $matches[1]
      "New version `"$newVersion`" found...`n"

      # Pack working dir (dont rebuild)
      "Creating Nuget package(s):"
      dotnet pack --no-restore --no-build --configuration $env:BUILD_CONFIGURATION -p:PackageVersion=$newVersion | Render-Body

      # Publish to nuget.org
      "Publishing packages:"
      $packages = get-childitem src *.nupkg -Recurse
      foreach($package in $packages) {
        dotnet nuget push $package.fullname --source $env:NUGET_ENDPOINT --api-key $env:NUGET_API_KEY | Render-Body
      }

      # Create new tag
      "Tagging commit:"      
      $commitAuthorName = git show --pretty="%an" --quiet
      "    Commit author name: " + $commitAuthorName
      git config user.name $commitAuthorName
      
      $commitAuthorEmail = git show --pretty="%ae" --quiet
      "    Commit author email: " + $commitAuthorEmail
      git config user.email $commitAuthorEmail

      git tag -a $newVersion -m "Azure build ID: $env:BUILDID"

      $uri = $env:BUILD_REPOSITORY_URI -replace "github.com", "$(githubPat)@github.com"
      "`nPushing tag to Github:"
      git push -u $uri $newVersion -q | Render-Body
      "Tag $newVersion created and pushed to origin."
    displayName: "Deploy Nuget Package and Tag Commit"
    # TODO When template parameters can be used in scripts, remove this - https://github.com/Microsoft/azure-pipelines-agent/issues/1772
    env:
      CHANGELOG_PATH: ${{parameters.changelogPath}}
      VERSION_HEADER_PATTERN: ${{parameters.versionHeaderPattern}}
      NUGET_ENDPOINT: ${{parameters.nugetEndpoint}}
      NUGET_API_KEY: ${{parameters.nugetApiKey}}
      BUILD_CONFIGURATION: ${{parameters.buildConfiguration}}