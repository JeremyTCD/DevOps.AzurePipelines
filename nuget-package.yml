jobs:
# Build
- job: Build
  pool:
    vmImage: 'vs2017-win2016'
  steps:
  - powershell: |
      dotnet build --configuration Release -p:CopyLocalLockFileAssemblies=true
      # Unhide .git folder and rename it so that PublishPipelineArtifact picks it up
      attrib -h .git
      rename-item .git git
  # Publish entire working directory to artifacts - https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases?view=vsts&tabs=yaml#artifact-download
  - task: PublishPipelineArtifact@0
    displayName: 'Publish Working Directory'
    inputs:
      artifactName: builtSolution
      targetPath: $(System.DefaultWorkingDirectory)
# Test
- template: nuget-package-test.yml
  parameters:
    name: WindowsTests
    vmImage: 'vs2017-win2016'
- template: nuget-package-test.yml
  parameters:
    name: LinuxTests
    vmImage: 'ubuntu-16.04'
- template: nuget-package-test.yml
  parameters:
    name: macOSTests
    vmImage: 'macOS-10.13'
# Deploy
- job: Deploy
  dependsOn:
  - LinuxTests
  - WindowsTests
  - macOSTests
  steps:
  - checkout: none
  # Download entire working directory from artifacts
  - task: DownloadPipelineArtifact@0
    displayName: 'Download Working Directory'
    inputs:
      artifactName: builtSolution
      targetPath: $(System.DefaultWorkingDirectory)
  # TODO badge (not affected by pull requests), pipeline variables, symbols, code coverage, docs
  - powershell: |
      # We've set triggers to commits to master and commits to branches with open pull requests 
      # to master. Only commits to master might have stuff to deploy.
      # TODO If we use $env:BUILD_REASON -eq 'PullRequest', do manual rebuilds cause deploys?
      "Current commit's branch: " + $env:BUILD_SOURCEBRANCHNAME
      if($env:BUILD_SOURCEBRANCHNAME -ne 'master'){
        "Pull request build, nothing to deploy"
        exit
      }
      "Commit is a merge commit into master..."

      # .git folder was named git so that PublishPipelineArtifact picked it up
      rename-item git .git
      
      # Initialize ps variables (consider using pipeline variables)
      $commit = $env:BUILD_SOURCEVERSION
      $file = 'changelog.md'
      $versionHeaderPattern = '^\+##[ \t]*\[(\d+\.\d+\.\d+)\]'
      $nugetEndpoint = 'https://staging.nuget.org/api/v2/package'
      $nugetApiKey = "$(nugetApiKey)" # Secret variables do not work for pull request builds, if we want to deploy from such builds, we need to use a service connection.

      # Check whether changelog has changed
      # Note: -m displays a diff of the parents of a merge commit
      $changedFiles = git show -m --pretty="" --name-only $commit
      "Changed files:"
        $changedFiles
      if(-not($changedFiles -contains $file)) {
        "Changelog unchanged, nothing to deploy."
        exit
      }
      "Changelog has changed..."

      # Check whether changelog has a new version
      $diff = git diff --unified=0 $commit^ $commit -- $file 
      "Diff:"
      $diff
      $newVersionLines = $diff -match $versionHeaderPattern
      if($newVersionLines.Length -gt 1) {
        throw "More than one new versions found, correct changelog or deploy releases manually."
      }
      if($newVersionLines.length -eq 0) {
        "No new versions, nothing to deploy."
        exit
      }
      $newVersionLines[0] -match $versionHeaderPattern
      $newVersion = $matches[1]
      "New version `"$newVersion`" found..."

      # Check whether tag exists for version
      $tags = git tag -l
      "Existing tags:"
      $tags
      if($tags -contains $newVersion) {
        "New version already deployed, nothing to deploy."
        exit
      }
      "New version not deployed yet, deploying..."

      # Pack working dir (dont rebuild)
      dotnet pack --no-restore --no-build --configuration Release -p:PackageVersion=$newVersion

      # Publish to nuget.org
      $packages = get-childitem src *.nupkg -Recurse
      "Packages:"
      $packages
      foreach($package in $packages) {
        # TODO fail build if pushing fails (unless package is already published)
        dotnet nuget push $package.fullname --source $nugetEndpoint --api-key $nugetApiKey
      }

      # Create new tag
      $commitAuthorName = git show --pretty="%an" --quiet
      "Commit author name: " + $commitAuthorName
      git config user.name $commitAuthorName
      
      $commitAuthorEmail = git show --pretty="%ae" --quiet
      "Commit author email: " + $commitAuthorEmail
      git config user.email $commitAuthorEmail

      git tag -a $newVersion -m "Azure build ID: $env:BUILDID"

      $uri = $env:BUILD_REPOSITORY_URI -replace "github.com", "$(githubPat)@github.com"
      git push -u $uri $newVersion -q
      "Tag $newVersion created and pushed to origin."