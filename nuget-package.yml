# Notes
# - Secret variables do not work for pull request builds, if we want to deploy from such builds, we need some other way to handle Git and Nuget personal access tokens
# - what is https://docs.microsoft.com/en-us/azure/devops/pipelines/build/ci-public?view=vsts&tabs=github? can it be used instead of PAT?

# TODO docs

parameters:
  nugetRestoreVstsFeed: "NugetFeed"
  buildConfiguration: "Release"
  runInheritDoc: true
  runTests: true
  runCodeCoverage: true
  codecovKey: "$(codecovKey)"
  changelogPath: "CHANGELOG.md"
  versionHeaderPattern: '^##[ \t]*\[(\d+\.\d+\.\d+[0-9A-Za-z-.]*)\]'
  nugetPushEndpoint: "https://www.nuget.org/api/v2/package"
  nugetPushApiKey: "$(nugetPushApiKey)"
  nugetPushVstsFeed: ""
  githubPat: "$(githubPat)"

jobs:
# Build
- job: "Build"
  pool:
    vmImage: "vs2017-win2016"
  steps:
  # If vsts feed is not specified, use dotnet restore (this will automatically use any provided nuget.config)
  - powershell: dotnet restore
    condition: ${{not(parameters.nugetRestoreVstsFeed)}}
    displayName: "Restore"
  - task: "DotNetCoreCLI@2"
    condition: ${{ne(parameters.nugetRestoreVstsFeed, '')}}
    displayName: "Restore"
    inputs: 
      command: "restore"
      includeNuGetOrg: false
      vstsFeed: ${{parameters.nugetRestoreVstsFeed}}
  - task: "DotNetCoreCLI@2"
    displayName: "Build"
    inputs: 
      command: "build"
      # TODO not sure why this doesn't work, possible - https://github.com/Microsoft/azure-pipelines-agent/issues/1772
      # arguments: --no-restore --configuration ${{parameters.buildConfiguration}} -p:CopyLocalLockFileAssemblies=true
      arguments: "--no-restore --configuration Release -p:CopyLocalLockFileAssemblies=true"
  - powershell: |
      function Render-Body { $input | foreach{@{value=$_}} | Format-Table -Property @{Expression={" "}},value -HideTableHeader -wrap}

      "Installing InheritDoc:"
      dotnet tool install InheritDocTool --tool-path . | Render-Body # Install to current dir https://github.com/dotnet/cli/issues/8368

      "Running InheritDoc:"
      .\InheritDoc.exe -b src -o | Render-Body

      # We won't be needing InheritDoc again in the pipeline
      remove-item .\InheritDoc.exe
      remove-item .\.store -recurse
    condition: ${{parameters.runInheritDoc}}
    displayName: "Handle <inheritdoc /> in XML Comments"
  - powershell: |
      # Unhide .git folder and rename it so that PublishPipelineArtifact picks it up
      attrib -h .git
      rename-item .git git
    displayName: "Prepare Intermediate Artifacts"
    env:
      BUILD_CONFIGURATION: ${{ parameters.buildConfiguration }} # TODO When template parameters can be used in scripts, remove this - https://github.com/Microsoft/azure-pipelines-agent/issues/1772
  # Publish entire working directory to artifacts - https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases?view=vsts&tabs=yaml#artifact-download
  - task: "PublishPipelineArtifact@0"
    displayName: "Publish Working Directory"
    inputs:
      artifactName: "builtSolution"
      targetPath: "$(System.DefaultWorkingDirectory)"
# Test
- job: "WindowsTests"
  dependsOn: "Build"
  # TODO why doesn't this work? - condition: ${{and(parameters.runTests, succeeded())}}
  # This also doesn't work - and(${{parameters.runTests}}, succeeded())
  # Test run even if build fails
  condition: ${{parameters.runTests}}
  pool:
    vmImage: "vs2017-win2016"
  steps:
  # Skip checking out the default repository resource
  - checkout: "none"
  # Download entire working directory from pipeline artifacts
  - task: "DownloadPipelineArtifact@0"
    displayName: "Download Working Directory"
    inputs:
      artifactName: "builtSolution"
      targetPath: "$(System.DefaultWorkingDirectory)"
  # If vsts feed not specified, use dotnet restore (this will automatically use any provided nuget.config)
  - powershell: dotnet restore
    condition: ${{not(parameters.nugetRestoreVstsFeed)}}
    displayName: "Restore"
  # Restore from Azure Artifacts feed for quicker restore (coverlet assemblies are required)
  - task: "DotNetCoreCLI@2"
    condition: ${{ne(parameters.nugetRestoreVstsFeed, '')}}
    displayName: "Restore"
    inputs: 
      command: "restore"
      includeNuGetOrg: false
      vstsFeed: ${{parameters.nugetRestoreVstsFeed}}
  # Test and handle code coverage report
  - powershell: |
      function Render-Body { $input | foreach{@{value=$_}} | Format-Table -Property @{Expression={" "}},value -HideTableHeader -wrap}

      "Running tests:"
      dotnet test --no-build --no-restore --configuration Release --logger trx --results-directory $(Agent.TempDirectory) -p:CollectCoverage=$env:RUN_CODE_COVERAGE -p:CoverletOutputFormat=cobertura | Render-Body

      # No reports
      $reports = get-childitem coverage.cobertura.xml -Recurse | foreach{$_.fullname}
      if($reports.length -eq 0){
        "No code coverage reports generated..."
        exit
      }

      # .git folder was named git so that PublishPipelineArtifact picked it up, codecov must be run from the root of a repository
      rename-item git .git

      # Publish report to codecov
      "Publishing code coverage report(s)...`n"

      "Installing Codecov:"      
      choco install codecov --yes --no-progress --cache-location=. | Render-Body 

      "Publishing to Codecov:"
      codecov -f $reports -t "$env:CODECOV_KEY" --required | Render-Body # Exit code 1 if uploading of report fails, otherwise it may fail silently
    displayName: "Test and Publish Code Coverage Report"
    #TODO remove once parameters can be used directly in scripts
    env:
      CODECOV_KEY: ${{parameters.codecovKey}}
      RUN_CODE_COVERAGE: ${{parameters.runCodeCoverage}}
  - task: "PublishTestResults@2"
    inputs:
      testResultsFormat: "VSTest"
      testResultsFiles: "**/*.trx"
      searchFolder: "$(Agent.TempDirectory)"
      testRunTitle: "WindowsTests"
- template: "nuget-package-test.yml"
  parameters:
    name: "LinuxTests"
    vmImage: "ubuntu-16.04"
    buildConfiguration: ${{ parameters.buildConfiguration }}
    runTests: ${{ parameters.runTests }}    
- template: "nuget-package-test.yml"
  parameters:
    name: "macOSTests"
    vmImage: "macOS-10.13"
    buildConfiguration: ${{ parameters.buildConfiguration }}
    runTests: ${{ parameters.runTests }}
# Deploy
- job: "Deploy"
  dependsOn:
  - "WindowsTests"
  - "LinuxTests"
  - "macOSTests"
  steps:
  - checkout: "none"
  # Download entire working directory from artifacts
  - task: "DownloadPipelineArtifact@0"
    displayName: "Download Working Directory"
    inputs:
      artifactName: "builtSolution"
      targetPath: "$(System.DefaultWorkingDirectory)"
  - powershell: |
      function Render-Body { $input | foreach{@{value=$_}} | Format-Table -Property @{Expression={" "}},value -HideTableHeader -wrap}

      # We've set triggers to commits to master and commits to branches with open pull requests 
      # to master. Only commits to master might have stuff to deploy.
      # TODO If we use $env:BUILD_REASON -eq 'PullRequest', do manual rebuilds cause deploys?
      if($env:BUILD_SOURCEBRANCHNAME -ne 'master'){
        "Pull request build, nothing to deploy"
        exit
      }
      "`nCommit is a merge commit into master...`n"

      # .git folder was named git so that PublishPipelineArtifact picked it up
      rename-item git .git
      
      # Initialize convenience variables
      $commit = $env:BUILD_SOURCEVERSION

      # Check whether changelog has changed
      # Note: -m displays a diff of the parents of a merge commit
      $changedFiles = git show -m --pretty="" --name-only $commit
      "Changed files:"
      $changedFiles | Render-Body 
      if(-not($changedFiles -contains $env:CHANGELOG_PATH)) {
        "Changelog unchanged, nothing to deploy."
        exit
      }
      "Changelog has changed...`n"

      # Check whether changelog has a new version
      $addedLines = git diff --unified=0 $commit^ $commit -- $env:CHANGELOG_PATH | foreach{if($_[0] -eq '+'){$_.Substring(1)}}
      "Added Lines:"
      $addedLines | Render-Body

      foreach($addedLine in $addedLines) {
        if($addedLine -match $env:VERSION_HEADER_PATTERN){
          $newVersion = $matches[1]
          break
        }
      }
      if(-not($newVersion)) {
        "No new version, nothing to deploy."
        exit
      }
      "New version `"$newVersion`" found...`n"
      echo "##vso[task.setvariable variable=newVersion]$newVersion"
    displayName: "Check for new version"
    # TODO When template parameters can be used in scripts, remove this - https://github.com/Microsoft/azure-pipelines-agent/issues/1772
    env:
      CHANGELOG_PATH: ${{parameters.changelogPath}}
      VERSION_HEADER_PATTERN: ${{parameters.versionHeaderPattern}}
  - powershell: |
      "Packing Nuget package(s):"
      dotnet pack --no-restore --no-build --configuration $env:BUILD_CONFIGURATION -p:PackageVersion=$newVersion | Render-Body
    displayName: "Pack Nuget Packages"
    env:
      BUILD_CONFIGURATION: ${{parameters.buildConfiguration}}
  - powershell: |
      # Push using endpoint and api key
      "Pushing packages:"
      $packages = get-childitem src *.nupkg -Recurse
      foreach($package in $packages) {
        dotnet nuget push $package.fullname --source $env:NUGET_ENDPOINT --api-key $env:NUGET_API_KEY | Render-Body
      }
    condition: ${{not(parameters.nugetRestoreVstsFeed)}}
    displayName: "Push Nuget Packages"
    env:
      NUGET_ENDPOINT: ${{parameters.nugetPushEndpoint}}
      NUGET_API_KEY: ${{parameters.nugetPushApiKey}}
  - task: "DotNetCoreCLI@2"
    condition: ${{ne(parameters.nugetPushVstsFeed, '')}}
    displayName: "Push Nuget Packages"
    inputs: 
      command: "push"
      vstsFeed: ${{parameters.nugetPushVstsFeed}}
  - powershell: |
      # Create new tag
      "Tagging commit:"      
      $commitAuthorName = git show --pretty="%an" --quiet
      "    Commit author name: " + $commitAuthorName
      git config user.name $commitAuthorName
      
      $commitAuthorEmail = git show --pretty="%ae" --quiet
      "    Commit author email: " + $commitAuthorEmail
      git config user.email $commitAuthorEmail

      git tag -a $newVersion -m "Azure build ID: $env:BUILDID"

      $uri = $env:BUILD_REPOSITORY_URI -replace "github.com", "$env:GITHUB_PAT@github.com"
      "`nPushing tag to Github:"
      git push -u $uri $newVersion -q | Render-Body
      "    Tag $newVersion pushed to Github."
    displayName: "Tag commit"
    env:
      GITHUB_PAT: ${{parameters.githubPat}}