# Notes
# - NUGET_PACKAGES
#   - Initially, NUGET_PACKAGES was set to $(system.defaultWorkingDirectory)/packages, enabling the following workflow:
#     1) download packages to the working directory in the build job, 2) upload packages to pipeline artifacts, 3) avoid re-restoring and rebuilding in test and deploy jobs.
#     This broke when DotNetCoreCLI@2 auto-updated to 2.144.3 (or possibly, when agents started using a newer version of the dotnet SDK), 
#     with the error message "To run tests with dotnet test add "<IsTestProject>true<IsTestProject>" property to project file." Example build: 
#     https://dev.azure.com/JeringTech/Markdig.Extensions.FlexiBlocks/_build/results?buildId=196. For some reason, Microsoft.Net.Test.SDK no longer sets IsTestProject automatically on Linux and MacOS.
#   - We now omit --no-restore and for tests (nuget/test.yml). Even if we can figure out why things broke, it's all just too brittle to bother saving ~10 seconds.

parameters:
  buildConfiguration: "Release"
  runInheritDoc: true
  runCodeCoverage: true
  codecovKey: "$(codecovKey)"
  changelogPath: "Changelog.md"
  releaseVersionHeaderPattern: '^##[ \t]*\[(\d+\.\d+\.\d+[0-9A-Za-z-.]*)\]'
  unreleasedVersionHeaderPattern: '^##[ \t]*\[Unreleased[ \t]*\((\d+\.\d+\.\d+[0-9A-Za-z-.]*)\)\]'
  nugetRestoreEndpoints: ""
  nugetRestorePats: ""
  nugetReleasePushEndpoint: "https://www.nuget.org/api/v2/package"
  nugetReleasePushPat: "$(nugetReleasePushPat)"
  nugetUnreleasedPrereleasePushEndpoint: ""
  nugetUnreleasedPrereleasePushPat: "$(nugetUnreleasedPrereleasePushPat)"
  nugetDistUrl: "https://dist.nuget.org/win-x86-commandline/v4.7.1/nuget.exe"
  githubPat: "$(githubPat)"
  nonWindowsFramework: "netcoreapp2.1"
  dotnetSdkVersion: "3.0.100"
  dotnetRuntimeVersions: ["2.1.13"]
  outOfProcessTestDependencies: []

jobs:
# Windows
- job: "WindowsBuildAndTest"
  pool:
    vmImage: "windows-2019"
  steps:
  - template: "build-and-test.yml"
    parameters:
      dotnetSdkVersion: ${{parameters.dotnetSdkVersion}}
      dotnetRuntimeVersions: ${{parameters.dotnetRuntimeVersions}}
      outOfProcessTestDependencies: ${{parameters.outOfProcessTestDependencies}}
      buildConfiguration: ${{parameters.buildConfiguration}}
      codecovKey: ${{parameters.codecovKey}}
      runCodeCoverage: ${{parameters.runCodeCoverage}}
  - template: "../shared/publish-working-directory.yml"
# Linux
- job: "LinuxBuildAndTest"
  pool:
    vmImage: "ubuntu-18.04"
  steps:
  - template: "build-and-test.yml"
    parameters:
      dotnetSdkVersion: ${{parameters.dotnetSdkVersion}}
      dotnetRuntimeVersions: ${{parameters.dotnetRuntimeVersions}}
      outOfProcessTestDependencies: ${{parameters.outOfProcessTestDependencies}}
      buildConfiguration: ${{parameters.buildConfiguration}}
      runCodeCoverage: false
      # TODO Figure out how to run .Net Framework test assemblies on Linux/macOS using mono. For now, only allow target framework to be specified so that
      # we can run only .Net Core test assemblies on Linux/macOS.
      extraArguments: "--framework ${{ parameters.nonWindowsFramework }}"
# Mac
- job: "MacOSBuildAndTest"
  pool:
    vmImage: "macOS-10.14"
  steps:
  - template: "build-and-test.yml"
    parameters:
      dotnetSdkVersion: ${{parameters.dotnetSdkVersion}}
      dotnetRuntimeVersions: ${{parameters.dotnetRuntimeVersions}}
      outOfProcessTestDependencies: ${{parameters.outOfProcessTestDependencies}}
      buildConfiguration: ${{parameters.buildConfiguration}}
      runCodeCoverage: false
      # TODO Figure out how to run .Net Framework test assemblies on Linux/macOS using mono. For now, only allow target framework to be specified so that
      # we can run only .Net Core test assemblies on Linux/macOS.
      extraArguments: "--framework ${{ parameters.nonWindowsFramework }}"
# Deploy
- job: "Deploy"
  pool:
    vmImage: "windows-2019"
  dependsOn:
  - "WindowsBuildAndTest"
  - "LinuxBuildAndTest"
  - "MacOSBuildAndTest"
  steps:
  - checkout: "none"
  - template: "../shared/download-working-directory.yml"
  - template: "../shared/find-new-version.yml"
    parameters:
      changelogPath: ${{parameters.changelogPath}}
      releaseVersionHeaderPattern: ${{parameters.releaseVersionHeaderPattern}}
      unreleasedVersionHeaderPattern: ${{parameters.unreleasedVersionHeaderPattern}}
      findUnreleasedPrereleaseVersion: ${{ne(parameters.nugetUnreleasedPrereleasePushEndpoint, '')}}
  # TODO this doesn't need to run if new version isn't defined
  - template: "./install-dotnet.yml"
    parameters:
      dotnetSdkVersion: ${{parameters.dotnetSdkVersion}}
      dotnetRuntimeVersions: ${{parameters.dotnetRuntimeVersions}}
  - powershell: |
      function Render-Body { $input | foreach{@{value=$_}} | Format-Table -Property @{Expression={" "}},value -HideTableHeader -wrap}

      if("${{parameters.runInheritDoc}}" -eq 'true'){
        "Installing InheritDoc:"
        dotnet tool install InheritDocTool --tool-path . --version 2.0.2 | Render-Body # Install to current dir https://github.com/dotnet/cli/issues/8368
        if($lastExitCode -ne 0){
          throw "Failed to install InheritDoc."
        }

        "Running InheritDoc:"
        ./InheritDoc.exe -b src -o | Render-Body
        if($lastExitCode -ne 0){
          throw "An error occurred when running InheritDoc."
        }
      }
    displayName: "Run InheritDoc"
    condition: and(succeeded(), ne(variables['newVersion'], ''))
    env:
      DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  - powershell: |
      function Render-Body { $input | foreach{@{value=$_}} | Format-Table -Property @{Expression={" "}},value -HideTableHeader -wrap}

      "Restoring packages:"
      dotnet restore | Render-Body
      if($lastExitCode -ne 0){
        throw "Failed to restore packages."
      }

      "Packing Nuget package(s):"
      dotnet pack --no-restore --no-build --configuration "${{parameters.buildConfiguration}}" -p:PackageVersion=$env:NEWVERSION | Render-Body
      if($lastExitCode -ne 0){
        throw "Failed to pack package(s). A project probably isn't properly configured."
      }

      # Push using endpoint and api key
      "Pushing packages:"
      $nugetPushEndpoint = if($env:NEWVERSIONISRELEASE){"${{parameters.nugetReleasePushEndpoint}}"}else{"${{parameters.nugetUnreleasedPrereleasePushEndpoint}}"}
      $nugetPushPat = if($env:NEWVERSIONISRELEASE){"${{parameters.nugetReleasePushPat}}"}else{"${{parameters.nugetUnreleasedPrereleasePushPat}}"}
      $packages = get-childitem src *.nupkg -Recurse
      foreach($package in $packages) {
        $message = dotnet nuget push $package.fullname --source $nugetPushEndpoint --api-key $nugetPushPat
        $message | Render-body

        # 409 returned if a package with the provided ID and version already exists - https://docs.microsoft.com/en-us/nuget/api/package-publish-resource#push-a-package
        if($lastExitCode -ne 0){
          # So dirty
          if(($message.Length -eq 4) -and $message[3].Contains(" 409 ")){
            # If error occurred because package already exists, allow pipeline to continue
            "$($package.name) already exists in feed $nugetPushEndpoint..."
          }else{
            throw "An unexpected error occurred while attempting to publish $package. If it was an intermittent issue, do a manual rebuild of the same commit ($env:BUILD_SOURCEVERSION). Otherwise, rectify the issue and merge the changes into master to trigger a CI build."
          }
        }
      }

      # If we get here, any failed publish attempts were because the package already exists
      exit 0
    displayName: "Push"
    condition: and(succeeded(), ne(variables['newVersion'], ''))
  - template: "../shared/tag-commit.yml"
    parameters:
      githubPat: ${{parameters.githubPat}}