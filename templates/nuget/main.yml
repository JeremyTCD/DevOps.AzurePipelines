parameters:
  buildConfiguration: "Release"
  runInheritDoc: true
  runTests: true
  runCodeCoverage: true
  codecovKey: "$(codecovKey)"
  changelogPath: "CHANGELOG.md"
  releaseVersionHeaderPattern: '^##[ \t]*\[(\d+\.\d+\.\d+[0-9A-Za-z-.]*)\]'
  unreleasedVersionHeaderPattern: '^##[ \t]*\[Unreleased[ \t]*\((\d+\.\d+\.\d+[0-9A-Za-z-.]*)\)\]'
  # TODO allow for multiple restore endpoints
  nugetRestoreEndpoint: ""
  nugetRestorePat: ""
  nugetReleasePushEndpoint: "https://www.nuget.org/api/v2/package"
  nugetReleasePushPat: "$(nugetReleasePushPat)"
  nugetUnreleasedPrereleasePushEndpoint: ""
  nugetUnreleasedPrereleasePushPat: "$(nugetUnreleasedPrereleasePushPat)"
  nugetDistUrl: "https://dist.nuget.org/win-x86-commandline/v4.7.1/nuget.exe"
  githubPat: "$(githubPat)"
  nonWindowsTestsTargetFramework: "netcoreapp2.1"

jobs:
# Build
- job: "NugetBuild"
  pool:
    vmImage: "vs2017-win2016"
  steps:
  - ${{if ne(parameters.nugetRestoreEndpoint, '')}}:
    - template: "../shared/set-nuget-restore-endpoint.yml"
      parameters: 
        nugetRestoreEndpoint: ${{parameters.nugetRestoreEndpoint}}
        nugetRestorePat: ${{parameters.nugetRestorePat}}
        nugetDistUrl: ${{parameters.nugetDistUrl}}
  - powershell: |
      function Render-Body { $input | foreach{@{value=$_}} | Format-Table -Property @{Expression={" "}},value -HideTableHeader -wrap}

      # Place cache in working directory so that it is uploaded to pipeline artifacts
      $env:NUGET_PACKAGES=$env:SYSTEM_DEFAULTWORKINGDIRECTORY + "/packages"

      "Restoring packages:"
      dotnet restore | Render-Body
      if($lastExitCode -ne 0){
        throw "Failed to restore dependencies."
      }

      "Building solution:"
      dotnet build --no-restore --configuration ${{parameters.buildConfiguration}} -p:CopyLocalLockFileAssemblies=true | Render-Body
      if($lastExitCode -ne 0){
        throw "Failed to build solution."
      }

      if("${{parameters.runInheritDoc}}" -eq 'true'){
        "Installing InheritDoc:"
        dotnet tool install InheritDocTool --tool-path . --version 2.0.2 | Render-Body # Install to current dir https://github.com/dotnet/cli/issues/8368
        if($lastExitCode -ne 0){
          throw "Failed to install InheritDoc."
        }

        "Running InheritDoc:"
        .\InheritDoc.exe -b src -o | Render-Body
        if($lastExitCode -ne 0){
          throw "An error occurred when running InheritDoc."
        }

        # We won't be needing InheritDoc again in the pipeline
        remove-item .\InheritDoc.exe
        remove-item .\.store -recurse
      }
    displayName: "Build"
  - template: "../shared/publish-working-directory.yml"
# Test
- ${{if eq(parameters.runTests, 'true')}}:
  - job: "NugetWindowsTests"
    dependsOn: "NugetBuild"
    pool:
      vmImage: "vs2017-win2016"
    steps:
    - template: "test.yml"
      parameters:
        buildConfiguration: ${{ parameters.buildConfiguration }}
        targetFramework: ${{ parameters.nonWindowsTestsTargetFramework }}
        runCodeCoverage: "${{ parameters.runCodeCoverage }}"
    # Publish code coverage reports
    - powershell: |
        function Render-Body { $input | foreach{@{value=$_}} | Format-Table -Property @{Expression={" "}},value -HideTableHeader -wrap}

        $reports = get-childitem coverage.cobertura.xml -Recurse | foreach{$_.fullname}
        # No reports
        if($reports.length -eq 0){
          "No code coverage reports generated..."
          exit
        }

        # Publish report to codecov
        "Publishing code coverage report(s)...`n"

        "Installing Codecov:"      
        choco install codecov --yes --no-progress --cache-location=. | Render-Body 
        if($lastExitCode -ne 0){
          throw "Failed to install Codecov."
        }

        "Publishing to Codecov:"
        codecov -f $reports -t "${{parameters.codecovKey}}" --required | Render-Body # Exit code 1 if uploading of report fails, otherwise it may fail silently
        if($lastExitCode -ne 0){
          throw "Failed to upload code coverage reports to Codecov."
        }
      displayName: "Publish code coverage reports"
  - job: "NugetLinuxTests"
    dependsOn: "NugetBuild"
    pool:
      vmImage: "ubuntu-16.04"
    steps:
    - template: "test.yml"
      parameters:
        buildConfiguration: ${{ parameters.buildConfiguration }}
        # TODO Figure out how to run .Net Framework test assemblies on Linux/macOS using mono. For now, only allow target framework to be specified so that
        # we can run only .Net Core test assemblies on Linux/macOS.
        extraArguments: "--framework ${{ parameters.nonWindowsTestsTargetFramework }}"
  - job: "NugetMacOSTests"
    dependsOn: "NugetBuild"
    pool:
      vmImage: "macOS-10.13"
    steps:
    - template: "test.yml"
      parameters:
        buildConfiguration: ${{ parameters.buildConfiguration }}
        extraArguments: "--framework ${{ parameters.nonWindowsTestsTargetFramework }}"
# Deploy
- job: "NugetDeploy"
  pool:
    vmImage: "vs2017-win2016"
  dependsOn:
  - ${{if eq(parameters.runTests, 'true')}}:
    - "NugetWindowsTests"
    - "NugetLinuxTests"
    - "NugetMacOSTests"
  - ${{if ne(parameters.runTests, 'true')}}:
    - "NugetBuild"
  steps:
  - checkout: "none"
  - template: "../shared/download-working-directory.yml"
  - template: "../shared/find-new-version.yml"
    parameters:
      changelogPath: ${{parameters.changelogPath}}
      releaseVersionHeaderPattern: ${{parameters.releaseVersionHeaderPattern}}
      unreleasedVersionHeaderPattern: ${{parameters.unreleasedVersionHeaderPattern}}
      findUnreleasedPrereleaseVersion: ${{ne(parameters.nugetUnreleasedPrereleasePushEndpoint, '')}}
  - powershell: |
      function Render-Body { $input | foreach{@{value=$_}} | Format-Table -Property @{Expression={" "}},value -HideTableHeader -wrap}

      # Make sure dotnet knows to look for packages in ./packages
      $env:NUGET_PACKAGES=$env:SYSTEM_DEFAULTWORKINGDIRECTORY + "/packages"

      "Packing Nuget package(s):"
      dotnet pack --no-restore --no-build --configuration "${{parameters.buildConfiguration}}" -p:PackageVersion=$env:NEWVERSION | Render-Body
      if($lastExitCode -ne 0){
        throw "Failed to pack packages. A project probably isn't properly configured."
      }

      # Push using endpoint and api key
      "Pushing packages:"
      $nugetPushEndpoint = if($env:NEWVERSIONISRELEASE){"${{parameters.nugetReleasePushEndpoint}}"}else{"${{parameters.nugetUnreleasedPrereleasePushEndpoint}}"}
      $nugetPushPat = if($env:NEWVERSIONISRELEASE){"${{parameters.nugetReleasePushPat}}"}else{"${{parameters.nugetUnreleasedPrereleasePushPat}}"}
      $packages = get-childitem src *.nupkg -Recurse
      foreach($package in $packages) {
        $message = dotnet nuget push $package.fullname --source $nugetPushEndpoint --api-key $nugetPushPat
        $message | Render-body

        # 409 returned if a package with the provided ID and version already exists - https://docs.microsoft.com/en-us/nuget/api/package-publish-resource#push-a-package
        if($lastExitCode -ne 0){
          if($message -contains ' 409 '){
            # If error occurred because package already exists, allow pipeline to continue
            "$($package.fullname) already exists..."
          }else{
            throw "An unexpected error occurred while attempting to publish $package. If it was an intermittent issue, do a manual rebuild of the same commit ($env:BUILD_SOURCEVERSION). Otherwise, rectify the issue and merge the changes into master to trigger a CI build."
          }
        }
      }

      # If we get here, any failed publish attempts were because the package already exists
      exit 0
    displayName: "Push"
    condition: and(succeeded(), ne(variables['newVersion'], ''))
  - template: "../shared/tag-commit.yml"
    parameters:
      githubPat: ${{parameters.githubPat}}